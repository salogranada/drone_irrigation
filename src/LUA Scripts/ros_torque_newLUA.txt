function avance_callback(msg)
    -- This is the subscriber callback function
    avance = msg.data
end

function avance_eu_callback(msg)
    -- This is the subscriber callback function
    avance_eu = msg.data
end

function sysCall_init() 
    simRemoteApi.start(19999)
    rosInterfacePresent=simROS
    
    -- Prepare the float32 publisher and subscriber (we subscribe to the topic we advertise):
    if rosInterfacePresent then
        publisher=simROS.advertise('/simulationTime','std_msgs/Float32')
        publisher2=simROS.advertise('/realTime','std_msgs/Float32')
        publisher_force=simROS.advertise('/force','std_msgs/Float32MultiArray')
        subs_avance=simROS.subscribe('/drone_nextPose','std_msgs/Float32MultiArray','avance_callback')
        subs_avance_eu=simROS.subscribe('/drone_nextEuler','std_msgs/Float32MultiArray','avance_eu_callback')
    end
    
    -- Make sure we have version 2.4.13 or above (the particles are not supported otherwise)
    v=sim.getInt32Param(sim.intparam_program_version)
    if (v<20413) then
        sim.displayDialog('Warning','The propeller model is only fully supported from V-REP version 2.4.13 and above.&&nThis simulation will not run as expected!',sim.dlgstyle_ok,false,'',nil,{0.8,0,0,0,0,0})
    end

    -- This control algo was quickly written and is dirty and not optimal. It just serves as a SIMPLE example

    d=sim.getObjectHandle('Quadricopter_base')

    propellerScripts={-1,-1,-1,-1}
    for i=1,4,1 do
        propellerScripts[i]=sim.getScriptHandle('Quadricopter_propeller_respondable'..i)
    end
    respondable={-1,-1,-1,-1}
    for i=1,4,1 do
        respondable[i]=sim.getObjectHandle('Quadricopter_propeller_respondable'..i)
    end
    heli=sim.getObjectHandle(sim.handle_self)

    particlesTargetVelocities={0,0,0,0}

    pParam=2
    iParam=0
    dParam=0
    vParam=-2

    cumul=0
    lastE=0
    pAlphaE=0
    pBetaE=0
    psp2=0
    psp1=0

    prevEuler=0

    avance = sim.getObjectPosition(d,-1)
    avance_eu = sim.getObjectOrientation(d,-1)

    fakeShadow=sim.getScriptSimulationParameter(sim.handle_self,'fakeShadow')
    if (fakeShadow) then
        shadowCont=sim.addDrawingObject(sim.drawing_discpoints+sim.drawing_cyclic+sim.drawing_25percenttransparency+sim.drawing_50percenttransparency+sim.drawing_itemsizes,0.2,0,-1,1)
    end

    -- Prepare 2 floating views with the camera views:
    floorCam=sim.getObjectHandle('Quadricopter_floorCamera')
    frontCam=sim.getObjectHandle('Quadricopter_frontCamera')
    floorView=sim.floatingViewAdd(0.9,0.9,0.2,0.2,0)
    frontView=sim.floatingViewAdd(0.7,0.9,0.2,0.2,0)
    sim.adjustView(floorView,floorCam,64)
    sim.adjustView(frontView,frontCam,64)
end

function sysCall_cleanup() 
    --sim.removeDrawingObject(shadowCont)
    sim.floatingViewRemove(floorView)
    sim.floatingViewRemove(frontView)
        -- Following not really needed in a simulation script (i.e. automatically shut down at simulation end):
    if rosInterfacePresent then
        simROS.shutdownPublisher(publisher)
        simROS.shutdownPublisher(publisher2)
        simROS.shutdownPublisher(publisher_force)
    end
end 

function sysCall_actuation() 
        -- Send an updated simulation time message, and send the transform of the object attached to this script:
    
    s=sim.getObjectSizeFactor(d)
    
    pos=sim.getObjectPosition(d,-1)
    ori=sim.getObjectOrientation(d,-1)
    if (fakeShadow) then
        itemData={pos[1],pos[2],0.002,0,0,1,0.2*s}
        sim.addDrawingObjectItem(shadowCont,itemData)
    end
    
    -- Vertical control:
    --targetPos=sim.getObjectPosition(targetObj,-1)
    targetPos = avance
    pos=sim.getObjectPosition(d,-1)
    l=sim.getVelocity(heli)
    e=(targetPos[3]-pos[3])
    cumul=cumul+e
    pv=pParam*e
    thrust=5.335+pv+iParam*cumul+dParam*(e-lastE)+l[3]*vParam
    lastE=e
    
    -- Horizontal control: 
    --sp=__getObjectPosition__(targetObj,d)
    sp_x = avance[1] - pos[1]
    sp_y = avance[2] - pos[2]
    sp_z = avance[3] - pos[3]
    sp= {sp_x, sp_y, sp_z}
    m=sim.getObjectMatrix(d,-1)
    vx={1,0,0}
    vx=sim.multiplyVector(m,vx)
    vy={0,1,0}
    vy=sim.multiplyVector(m,vy)
    alphaE=(vy[3]-m[12])
    alphaCorr=0.25*alphaE+2.1*(alphaE-pAlphaE)
    betaE=(vx[3]-m[12])
    betaCorr=-0.25*betaE-2.1*(betaE-pBetaE)
    pAlphaE=alphaE
    pBetaE=betaE
    alphaCorr=alphaCorr+sp[2]*0.005+1*(sp[2]-psp2)
    betaCorr=betaCorr-sp[1]*0.005-1*(sp[1]-psp1)
    psp2=sp[2]
    psp1=sp[1]
    
    -- Rotational control:
    euler_x = ori[1] - avance_eu[1]
    euler_y = ori[2] - avance_eu[2]
    euler_z = ori[3] - avance_eu[3]
    --euler_x = avance_eu[1] - ori[1]
    --euler_y = avance_eu[2] - ori[2]
    --euler_z = avance_eu[3] - ori[3]
    --euler=__getObjectOrientation__(d,targetObj)
    euler = {euler_x, euler_y, euler_z}
    rotCorr=euler[3]*0.1+2*(euler[3]-prevEuler)
    prevEuler=euler[3]
    
    -- Decide of the motor velocities:
    particlesTargetVelocities[1]=thrust*(1-alphaCorr+betaCorr+rotCorr)
    particlesTargetVelocities[2]=thrust*(1-alphaCorr-betaCorr-rotCorr)
    particlesTargetVelocities[3]=thrust*(1+alphaCorr-betaCorr+rotCorr)
    particlesTargetVelocities[4]=thrust*(1+alphaCorr+betaCorr-rotCorr)
    --print(particlesTargetVelocities)
    -- Send the desired motor velocities to the 4 rotors:
    for i=1,4,1 do
        --sim.setScriptSimulationParameter(propellerScripts[i],'particleVelocity',particlesTargetVelocities[i])
        sim.addForce(respondable[i],{0,0,1},{0,0,particlesTargetVelocities[i]})
    end
    
    --Se Publican los parametros necesarios
    if rosInterfacePresent then
        simROS.publish(publisher,{data=sim.getSimulationTime()})
        simROS.publish(publisher2,{data=sim.getSystemTime()})
        simROS.publish(publisher_force,{data=particlesTargetVelocities})
        -- To send several transforms at once, use simROS.sendTransforms instead
    end
end 
